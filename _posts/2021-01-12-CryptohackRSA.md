---
title: RSA Writeups
categories:
- CryptoHack
excerpt: |
  
---

This is my writeup of the [CryptoHack RSA challenges](https://cryptohack.org/challenges/rsa).


### RSA Starter 1

Find the solution to 101<sup>17</sup> mod 22663.


SOLUTION <br>
Use the python pow function - pow(base, exponent, modulus)
```python
print(pow(101, 17, 22663))
```
This gives 19906.

### RSA Starter 2

"Encrypt" the number 12 using the exponent e = 65537 and the primes p = 17 and <br>q = 23. What number do you get as the ciphertext?


SOLUTION

We need to calculate the ciphertext number, let's call that c. 

We are given the number 12 to encrypt, usually this is part of a message so let's call that m. 

N = p x q = 17 * 23

In RSA, c = m<sup>e</sup> mod N.

We can calculate this in python:
```python
m = 12
N = 17*23
e = 65537

c = pow(m, e, N)
print(c)
```
This gives c = 301.

### RSA Starter 3
Given p = 857504083339712752489993810777 and <br>q = 1029224947942998075080348647219, what is the Euler totient of N?

SOLUTION

The Euler's totient of N, also known as phi(N) can be calculated as <br> 
phi = (p - 1) x (q - 1).
```python
p = 857504083339712752489993810777
q = 1029224947942998075080348647219
phi = (p - 1) * (q - 1)
print(phi)
```
This gives <br>phi = 882564595536224140639625987657529300394956519977044270821168.

### RSA Starter 4

Given <br>
p = 857504083339712752489993810777 <br>
q = 1029224947942998075080348647219 <br>
e = 65537

What is the private key d?

SOLUTION

In RSA, d = e<sup>-1</sup> mod phi(N).<br>
The numbers are the same as the last question, so we already know phi.
```python
phi = 882564595536224140639625987657529300394956519977044270821168 
e = 65537
d = pow(e, -1, phi)
print(d)
```
This gives <br>d = 121832886702415731577073962957377780195510499965398469843281 

### RSA Starter 5

Given <br>
N = 882564595536224140639625987659416029426239230804614613279163 <br> 
e = 65537 <br>
c = 77578995801157823671636298847186723593814843845525223303932 <br>
d from previous challenge <br>
(d = 121832886702415731577073962957377780195510499965398469843281)
Decrypt the cipher text. 

SOLUTION

The formula to decrypt RSA and get the message m is <br>
m = c<sup>d</sup> mod N.
```python
N = 882564595536224140639625987659416029426239230804614613279163
c = 77578995801157823671636298847186723593814843845525223303932
d = 121832886702415731577073962957377780195510499965398469843281
m = pow(c,d,N)
print(m)
```
This gives m = 13371337. 

### RSA Starter 6
Sign the flag crypto{Immut4ble_m3ssag1ng} using your private key and the SHA256 hash function. <br>
Enter the signature as hex. <br>
In the private.key file you can download, <br>
N = 15216583654836731327639981224133918855895948374072384050848479908982286890731769486609085918857664046075375253168955058743185664390273058074450390236774324903305663479046566232967297765731625328029814055635316002591227570271271445226094919864475407884459980489638001092788574811554149774028950310695112688723853763743238753349782508121985338746755237819373178699343135091783992299561827389745132880022259873387524273298850340648779897909381979714026837172003953221052431217940632552930880000919436507245150726543040714721553361063311954285289857582079880295199632757829525723874753306371990452491305564061051059885803<br>
d = 11175901210643014262548222473449533091378848269490518850474399681690547281665059317155831692300453197335735728459259392366823302405685389586883670043744683993709123180805154631088513521456979317628012721881537154107239389466063136007337120599915456659758559300673444689263854921332185562706707573660658164991098457874495054854491474065039621922972671588299315846306069845169959451250821044417886630346229021305410340100401530146135418806544340908355106582089082980533651095594192031411679866134256418292249592135441145384466261279428795408721990564658703903787956958168449841491667690491585550160457893350536334242689

SOLUTION

First hash crypto{Immut4ble_m3ssag1ng} using sha256. <br>
I used the online tool https://emn178.github.io/online-tools/sha256.html. <br>
Now we have a hash: <br>
H = 99b4c7bb814cc630c4199e4814ffed85a835f64ffc82aadaa6388d9df9aeb2cb.<br>

Next, convert H to decimal. <br>
Then, 'encrypt' H. The formula to sign the hash is (S = H<sup>d</sup> mod N). <br>
Finally, convert S from decimal to hex. 

```python
d = 11175901210643014262548222473449533091378848269490518850474399681690547281665059317155831692300453197335735728459259392366823302405685389586883670043744683993709123180805154631088513521456979317628012721881537154107239389466063136007337120599915456659758559300673444689263854921332185562706707573660658164991098457874495054854491474065039621922972671588299315846306069845169959451250821044417886630346229021305410340100401530146135418806544340908355106582089082980533651095594192031411679866134256418292249592135441145384466261279428795408721990564658703903787956958168449841491667690491585550160457893350536334242689
N = 15216583654836731327639981224133918855895948374072384050848479908982286890731769486609085918857664046075375253168955058743185664390273058074450390236774324903305663479046566232967297765731625328029814055635316002591227570271271445226094919864475407884459980489638001092788574811554149774028950310695112688723853763743238753349782508121985338746755237819373178699343135091783992299561827389745132880022259873387524273298850340648779897909381979714026837172003953221052431217940632552930880000919436507245150726543040714721553361063311954285289857582079880295199632757829525723874753306371990452491305564061051059885803

H = "99b4c7bb814cc630c4199e4814ffed85a835f64ffc82aadaa6388d9df9aeb2cb"
H = int(H, 16) #convert from hex to decimal

S = pow(H, d, N) #sign hash
print(hex(S)) #convert decimal to hex
```
This gives:
6ac9bb8f110b318a40ad8d7e57defdcce2652f5928b5f9b97c1504d7096d7af1d34e477b30f1a08014e8d525b14458b709a77a5fa67d4711bd19da1446f9fb0ffd9fdedc4101bdc9a4b26dd036f11d02f6b56f4926170c643f302d59c4fe8ea678b3ca91b4bb9b2024f2a839bec1514c0242b57e1f5e77999ee67c450982730252bc2c3c35acb4ac06a6ce8b9dbf84e29df0baa7369e0fd26f6dfcfb22a464e05c5b72baba8f78dc742e96542169710918ee2947749477869cb3567180ccbdfe6fdbe85bcaca4bf6da77c8f382bb4c8cd56dee43d1290ca856318c97f1756b789e3cac0c9738f5e9f797314d39a2ededb92583d97124ec6b313c4ea3464037d3

### Factoring

Factorise the 150-bit number 510143758735509025530880200653196460532653147 into its two constituent primes. Give the smaller one as your answer.

SOLUTION

There are many websites that factorise large numbers. E.g. http://factordb.com. <br>
You get 19704762736204164635843 and 25889363174021185185929. <br>
The smaller one is 19704762736204164635843.

### Inferius Prime

Given encryption script:
```python
from Crypto.Util.number import getPrime, inverse, bytes_to_long, long_to_bytes, GCD

e = 3

# n will be 8 * (100 + 100) = 1600 bits strong which is pretty good
while True:
    p = getPrime(100)
    q = getPrime(100)
    phi = (p - 1) * (q - 1)
    d = inverse(e, phi)
    if d != -1 and GCD(e, phi) == 1:
        break

n = p * q

flag = b"XXXXXXXXXXXXXXXXXXXXXXX"
pt = bytes_to_long(flag)
ct = pow(pt, e, n)

print(f"n = {n}")
print(f"e = {e}")
print(f"ct = {ct}")

pt = pow(ct, d, n)
decrypted = long_to_bytes(pt)
assert decrypted == flag
```

Given output: <br>
n = 742449129124467073921545687640895127535705902454369756401331 <br>
e = 3 <br>
ct = 39207274348578481322317340648475596807303160111338236677373 <br>


SOLUTION

We have to figure out what flag is. <br>
I'll call flag m for consistency with m for message in previous challenges. <br>
To decrypt the flag, we have to do: <br>
m = ct<sup>d</sup> mod n <br>
We have ct and n, so we just have to calculate the private key d. <br>
n is small so we can factorise using http://factordb.com. <br>
p = 752708788837165590355094155871 <br>
q = 986369682585281993933185289261 <br>
Using p and q we can calculate phi = (p - 1) * (q - 1)<br>
Using phi we can calculate d = pow(e, -1, phi)<br> 
Using d we can finally calculate m = pow(ct, d, n)<br>
But m is an integer, to convert to text we can use Crypto.Util.number long_to_bytes. <br>
To install this run "pip install pycryptodome".

```python
from Crypto.Util.number import long_to_bytes

e = 3
n = 742449129124467073921545687640895127535705902454369756401331 
ct = 39207274348578481322317340648475596807303160111338236677373 
p = 752708788837165590355094155871 
q = 986369682585281993933185289261 
phi = (p - 1) * (q - 1)
d = pow(e, -1, phi)
m = pow(ct, d, n)
print(long_to_bytes(m).decode())
```
This gives crypto{N33d_b1g_pR1m35}.

### Monoprime

We are given:
n = 171731371218065444125482536302245915415603318380280392385291836472299752747934607246477508507827284075763910264995326010251268493630501989810855418416643352631102434317900028697993224868629935657273062472544675693365930943308086634291936846505861203914449338007760990051788980485462592823446469606824421932591       <br>    e = 65537 <br>
ct = 161367550346730604451454756189028938964941280347662098798775466019463375610700074840105776873791605070092554650190486030367121011578171525759600774739890458414593857709994072516290998135846956596662071379067305011746842247628316996977338024343628757374524136260758515864509435302781735938531030576289086798942  <br>

And the message "Why is everyone so obsessed with multiplying two primes for RSA. Why not just use one?".

SOLUTION

Here n is prime, not the product of two primes. This allows us to work out phi easily.  <br>
phi(n) represents the number of non-negative integers less than n that are coprime to n. And if n is prime, every number lower than n will be coprime to n! <br>
Therefore phi = n-1.

```python
from Crypto.Util.number import long_to_bytes

e = 65537
n = 171731371218065444125482536302245915415603318380280392385291836472299752747934607246477508507827284075763910264995326010251268493630501989810855418416643352631102434317900028697993224868629935657273062472544675693365930943308086634291936846505861203914449338007760990051788980485462592823446469606824421932591 
ct = 161367550346730604451454756189028938964941280347662098798775466019463375610700074840105776873791605070092554650190486030367121011578171525759600774739890458414593857709994072516290998135846956596662071379067305011746842247628316996977338024343628757374524136260758515864509435302781735938531030576289086798942 
phi = n - 1
d = pow(e, -1, phi)
m = pow(ct, d, n)
print(long_to_bytes(m).decode())
```
This gives crypto{0n3_pr1m3_41n7_pr1m3_l0l}.

### Square Eyes

We are given:
N = 535860808044009550029177135708168016201451343147313565371014459027743491739422885443084705720731409713775527993719682583669164873806842043288439828071789970694759080842162253955259590552283047728782812946845160334801782088068154453021936721710269050985805054692096738777321796153384024897615594493453068138341203673749514094546000253631902991617197847584519694152122765406982133526594928685232381934742152195861380221224370858128736975959176861651044370378539093990198336298572944512738570839396588590096813217791191895941380464803377602779240663133834952329316862399581950590588006371221334128215409197603236942597674756728212232134056562716399155080108881105952768189193728827484667349378091100068224404684701674782399200373192433062767622841264055426035349769018117299620554803902490432339600566432246795818167460916180647394169157647245603555692735630862148715428791242764799469896924753470539857080767170052783918273180304835318388177089674231640910337743789750979216202573226794240332797892868276309400253925932223895530714169648116569013581643192341931800785254715083294526325980247219218364118877864892068185905587410977152737936310734712276956663192182487672474651103240004173381041237906849437490609652395748868434296753449 <br>
e = 65537 <br>
c = 222502885974182429500948389840563415291534726891354573907329512556439632810921927905220486727807436668035929302442754225952786602492250448020341217733646472982286222338860566076161977786095675944552232391481278782019346283900959677167026636830252067048759720251671811058647569724495547940966885025629807079171218371644528053562232396674283745310132242492367274184667845174514466834132589971388067076980563188513333661165819462428837210575342101036356974189393390097403614434491507672459254969638032776897417674577487775755539964915035731988499983726435005007850876000232292458554577437739427313453671492956668188219600633325930981748162455965093222648173134777571527681591366164711307355510889316052064146089646772869610726671696699221157985834325663661400034831442431209123478778078255846830522226390964119818784903330200488705212765569163495571851459355520398928214206285080883954881888668509262455490889283862560453598662919522224935145694435885396500780651530829377030371611921181207362217397805303962112100190783763061909945889717878397740711340114311597934724670601992737526668932871436226135393872881664511222789565256059138002651403875484920711316522536260604255269532161594824301047729082877262812899724246757871448545439896 <br>

and the text: It was taking forever to get a 2048 bit prime, so I just generated one and used it twice.

SOLUTION
