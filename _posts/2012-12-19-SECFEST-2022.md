---
title: SECFEST 2022
categories:
- Security Fest CTF
excerpt: |
  
---

Challenge files [here](https://github.com/Connor-McCartney/CTF-files/tree/main/SECFEST-2022)

### panta fler

Here 3 messages are XOR'd with the random key. <br>
Using the flag format and XORing byte by byte we can slowly guess the flag (changing key and increasing len).

```python
from Crypto.Util.strxor import strxor
from Crypto.Util.number import *
from string import printable

def is_printable(string):
    for c in string:
        if chr(c) not in  printable[:63] + "_" + " " + "}":
            return False
    return True

c1= b'\xc1=\x01}\xe7\x1c\x94YRj\xb3\xa7K@\xde\x0c\x9a\xc9\x00\xb0ZB\r\x87\r\x8b\x8f\xffQ\xc7'
c2= b'\xfc\x1d4^\xd0o\xb2GE|\x89\xe4^]\xcfE\x86\xdd\x1e\x8a\r@\x1c\x96r\x92\x87\xec\x19\xd4'
c3= b'\xfa\x19!P\x82;\xa8G\x10\x7f\x80\xa5DP\xdeE\x94\xc8S\x9cHH\x1f\x8a!\x87\xc0\xe3\x1f\xcd'

len = 8
key = strxor(c1[:len], b"SECFEST{")

for i in range(256):
    m1 = long_to_bytes(i ^ c1[len])
    m2 = long_to_bytes(i ^ c2[len])
    m3 = long_to_bytes(i ^ c3[len])
    if is_printable(m1) and is_printable(m2) and is_printable(m3):
        print(strxor(key, c1[:len]) + m1)
        print(strxor(key, c2[:len]) + m2)
        print(strxor(key, c3[:len]) + m3)
        print()
```

Eventually you can get: 

```
b'SECFEST{be_cautious_with_xor!}'
b'never reuse the same key again'
b'hack the planet at secfest now'
```


### really_sick_aesthetic

We have:

c1 = x^3 (mod n1) <br>
c2 = (ax + b)^3 (mod n2) <br>
c3 = (cx + d)^3 (mod n3)

and the hint len(flag) = 127 

We can shift each function, combine with CRT then use small_roots mod n1 * n2 * n3.

k = 'SECFEST{' <br>
m = k + x <br>
len(k) = 8, so len(x) is 127-8 = 119

```python
from Crypto.Util.number import *

n1, n2, n3 = 1401319611347356773887154859254297488587748916167528411781955161070771235056492239930915055430725842906735678800721088435590827145380843922331596331217195998289782451691023636938672246577057750538399961569425132775422780215874173061239620286809361247476788799084351705535705191719741473638161177830819062913, 93929270671640676038272300621577590050388546365573376058848268755586443513273392470288465422034947305882115935273812814090585070611845743805708732148965001758685938419891262987151989750411904643337379571106949332912476594370786031126592832074202606178259666176275819642895388993805423801590346121886463154493, 16942255048162971761210283484837728649885892177575028340105590631533021846865838703837850496337964481215216748513001294835312645433010478899804925326573174869703026494395537885248285153728354458825455324651596388723156984568435202926704664556435326575519823264262426064534649720827701655074670423046369428487
a, b, c, d = 816707757334025955873551300291115957244929178359163189898836703794096446035376642681339350269646402403623381300867313940921411937931855866555460115147443198624007849492344102900953388236705014598317668063410070421658320251867938311242756954445599777691127340178194758168120083391846957297043258538971682656, 745711826496100756612627309746963018286384869064570930929420181315701128858481411996420808944706255787336734726114648250308181091719587312246849339268467320198235168275114019618372903191004050047010404038580467357659473336645389978388162270444112395481987515683470136265832310695565656316066649488457251542, 457113559991336310217047954994454259015470269139045253465880453115425882867168371751366860291496286988706829825972982124718895516194348207894013000632929345548822790821065845244320278540909961203024618547366059145546677151699090715138478903903713059476077714630963005563020709732576278095273999695170245879, 509199941399276795750649828994710794297214191656907620132065560140027602600782775401578085170024829709169889862887726457343903644876293675737086407127920668618215833854745693576935098817794913606783358855099827179163328860990718950946614721022541431359002875691363746468433769282630310194268851308235950929
c1, c2, c3 = 1268196573919981524276949967801999986488529166073152640081117541596594438854836034605091034310174116029963325447867011142758840266458010604314712206281207486042576686131112279236592688360682514879866358817285786950878940051455988959409256539680442525853200118747541970284236278058810272505720905257745240883, 64208823083728071837064999419452205104115247850043866522128501646834783777966548620165452087334309723488367313973950057214802570403789761738914272552005923211386317615619928040804318066050436314100228196466534901781541660761105159754722013559344265999734902281442779083683166805632208178603445218079969320285, 8509227949500504626057408247321015695521219754070289890807066036172664538036554468734653260395519871677018843271256389298835987869898579912928540836245194980365843079281083074016559389213798536654944263567871852040147199080662496995097561192482940890984303786845410433468150776276754709196911737317257395314

Z1 = crt([1, 0, 0], [n1, n2, n3]) 
Z2 = crt([0, 1, 0], [n1 ,n2, n3]) 
Z3 = crt([0, 0, 1], [n1, n2, n3]) 

PR = PolynomialRing(Zmod(n1 * n2 * n3), "x")
x = PR.gen()

k = bytes_to_long(b'SECFEST{')
m = x + k * 2**(8*119)

f1 = m**3 - c1
f2 = (a*m+b)**3 - c2
f3 = (c*m+d)**3 - c3
f = f1 * Z1 + f2 * Z2 + f3 * Z3
print('small roots...')
roots = f.monic().small_roots(X=2**(8*119), epsilon=0.033) #can keep decreasing epsilon until it works
print(roots)

print(b'SECFEST{' + long_to_bytes(int(roots[0]))) #SECFEST{0xlol}
```

### small rsa

