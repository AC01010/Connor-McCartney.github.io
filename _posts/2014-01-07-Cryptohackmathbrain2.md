---
title: MATHEMATICS - Brainteasers Part 2
categories:
- CryptoHack
excerpt: |
  
---

This is my writeup of the [CryptoHack Mathematics challenges](https://cryptohack.org/challenges/maths/).



### Unencryptable

This challenge was a matter of bruteforcing to factorise N using gcd. 

```python
from math import gcd
from Crypto.Util.number import long_to_bytes
N = 0x7fe8cafec59886e9318830f33747cafd200588406e7c42741859e15994ab62410438991ab5d9fc94f386219e3c27d6ffc73754f791e7b2c565611f8fe5054dd132b8c4f3eadcf1180cd8f2a3cc756b06996f2d5b67c390adcba9d444697b13d12b2badfc3c7d5459df16a047ca25f4d18570cd6fa727aed46394576cfdb56b41
e = 0x10001
c = 0x5233da71cc1dc1c5f21039f51eb51c80657e1af217d563aa25a8104a4e84a42379040ecdfdd5afa191156ccb40b6f188f4ad96c58922428c4c0bc17fd5384456853e139afde40c3f95988879629297f48d0efa6b335716a4c24bfee36f714d34a4e810a9689e93a0af8502528844ae578100b0188a2790518c695c095c9d677b
m =0x372f0e88f6f7189da7c06ed49e87e0664b988ecbee583586dfd1c6af99bf20345ae7442012c6807b3493d8936f5b48e553f614754deb3da6230fa1e16a8d5953a94c886699fc2bf409556264d5dced76a1780a90fd22f3701fdbcb183ddab4046affdc4dc6379090f79f4cd50673b24d0b08458cdbe509d60a4ad88a7b4e2921

for i in range(1, 16):
    if gcd(m ** (2 ** i) - 1, N) != 1:
        p = gcd(m ** (2 ** i) - 1, N)
        break
q = N // p
phi = (p - 1) * (q - 1)
d = pow(e, -1, phi)
m = pow(c, d, N)
print(long_to_bytes(m).decode())
#crypto{R3m3mb3r!_F1x3d_P0iNts_aR3_s3crE7s_t00}
```

### Cofactor Cofantasy

This challenge boils down to distinguising if a given number c is either: <br>
a) random <br>
b) equal to g<sup>x</sup> mod N, for some random integer x

I started by finding divisors of phi to work with. 

```python
for i in range(1000):
    if phi % (2**i) == 0:
        print(i)
```

The largest I found was 2<sup>16</sup>. Now let M = phi//(2 ** 16). <br>

Next I looked at g<sup>M</sup> mod N and g<sup>2M</sup> mod N:

```python
print(pow(g, M, N)) # does not equal 1
print(pow(g, 2*M, N)) # equals 1
```

Let k = g<sup>M</sup> mod N. The fact that we know N is a product of distinct primes and that k is a square root of 1 mod N
allows us to factor N:

```python
from math import gcd
M = phi//(2**16)
k = pow(g, M, N)
a = gcd(N, k+1)
b = gcd(N, k-1)
```

We can observe g<sup>M</sup> = 1 mod b. <br>
Now if g<sup>M</sup> mod b == c<sup>M</sup> mod b, we can be pretty confident c is not random!

```python
from sage.all import *
from pwn import *
import json
r = remote('socket.cryptohack.org', 13398)
long2bytes = lambda x: x.to_bytes((x.bit_length() + 7) // 8, 'big')
N = 56135841374488684373258694423292882709478511628224823806418810596720294684253418942704418179091997825551647866062286502441190115027708222460662070779175994701788428003909010382045613207284532791741873673703066633119446610400693458529100429608337219231960657953091738271259191554117313396642763210860060639141073846574854063639566514714132858435468712515314075072939175199679898398182825994936320483610198366472677612791756619011108922142762239138617449089169337289850195216113264566855267751924532728815955224322883877527042705441652709430700299472818705784229370198468215837020914928178388248878021890768324401897370624585349884198333555859109919450686780542004499282760223378846810870449633398616669951505955844529109916358388422428604135236531474213891506793466625402941248015834590154103947822771207939622459156386080305634677080506350249632630514863938445888806223951124355094468682539815309458151531117637927820629042605402188751144912274644498695897277
phi = 56135841374488684373258694423292882709478511628224823806413974550086974518248002462797814062141189227167574137989180030483816863197632033192968896065500768938801786598807509315219962138010136188406833851300860971268861927441791178122071599752664078796430411769850033154303492519678490546174370674967628006608839214466433919286766123091889446305984360469651656535210598491300297553925477655348454404698555949086705347702081589881912691966015661120478477658546912972227759596328813124229023736041312940514530600515818452405627696302497023443025538858283667214796256764291946208723335591637425256171690058543567732003198060253836008672492455078544449442472712365127628629283773126365094146350156810594082935996208856669620333251443999075757034938614748482073575647862178964169142739719302502938881912008485968506720505975584527371889195388169228947911184166286132699532715673539451471005969465570624431658644322366653686517908000327238974943675848531974674382848
g = 986762276114520220801525811758560961667498483061127810099097

def json_recv():
    line = r.recvline()
    return json.loads(line.decode())

def json_send(hsh):
    request = json.dumps(hsh).encode()
    r.sendline(request)

def get_bit(i):
    for _ in range(2): #repeat more for better probability
        json_send({"option":"get_bit","i":str(i)})
        res = int(json_recv()["bit"],16)
        if pow(g, M, b) != pow(res, M, b):
            return "0"
    return "1"

M = phi//(2**16)
k = pow(g, M, N)
a = gcd(N, k+1)
b = gcd(N, k-1)

r.recvline()
flag = ""
for i in range(len(b"crypto{???????????????????????????????????}")*8):
    flag = get_bit(i) + flag
    if len(flag) % 8 == 0:
        print(long2bytes(int(flag, 2))[::-1])
#crypto{0ver3ng1neering_ch4lleng3_s0lution$}
```
