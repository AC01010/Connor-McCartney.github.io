---
title: HSSCTF 2022
categories:
- HSCTF
excerpt: |
  
---

### baby-baby-rsa

Challenge:

```python
from Crypto.Util.number import *
import random
flag = open('flag.txt','rb').read()
pt = bytes_to_long(flag)
bits = 768
p,q = getPrime(bits),getPrime(bits)
n = p*q
e = 0x10001
print(pow(pt,e,n))
bit_p = bin(p)[2:]
bit_q = bin(q)[2:]
parts = [bit_p[0:bits//3],bit_p[bits//3:2*bits//3],bit_p[2*bits//3:bits],bit_q[0:bits//3],bit_q[bits//3:2*bits//3],bit_q[2*bits//3:bits]]
random.shuffle(parts)
print(parts)
```

Output:

```
54794426723900547461854843163768660308115034417111329528183606035659639395104723918632912086419836023341428265596988959206660015436864401403237748771765948022232575597127381504670391300908215025163138869313954305720403722718214862988965792884236612959443476803344992121865817757791519151566895512058656532409472494022672998848036223706004788146906885182892250477746430460414866512005225936680732094537985671236900243908114730784290372829952741399684135984046796
['0100101100001100010110110001000001001110010110110011101111100001101100000101000011111000101110011010010100101100011111000000101010011101100101010000101101110100100010101011100110001010001000000001000110000111011110011001101111110000100010000110000001110011', '1100001100001100111110011110110101001100100000000100000100011110110010010101000011111111000100001000111001100110010010010011110110110010010110110100010110100011011100101001100001010111000100000110101010101011011110110110101010110100011110010000101010000111', '1000100010110110010100111010100100111000100111100101100001011111100011000111110011101011011011100000101011000111010110010010011110100100110000001101110111001000000111100111011011000101010001111101000111100111110010011101011111100100111111011011110110101111', '1111001101111101111111111111001010001111100010100000010110011011100000000110010110000011011110101110001000001111110101101101111000000111101111111000011101011010000110111100000110000001001101101010100000010011000100010111100001011000101101111000101101110100', '1100100000100001010111110010000011000010100110101111100100011010111111110100011011111100001011101001010000100111100011100111000101110001001011110000000000000000000110111100000111100000111111010110010011000010011000110111001010000110011011111101011110000101', '0001101000011011010011100100000011010101110110111001111011000001010101101111110100011011010011111010001111011011100011111110101110101101111100100011111110011111010100001100011000111011010111110101000011110101011110110001011110001111011001101100110100000101']
```

Solve:

```python
from itertools import permutations
from Crypto.Util.number import *

e = 0x10001
c = 54794426723900547461854843163768660308115034417111329528183606035659639395104723918632912086419836023341428265596988959206660015436864401403237748771765948022232575597127381504670391300908215025163138869313954305720403722718214862988965792884236612959443476803344992121865817757791519151566895512058656532409472494022672998848036223706004788146906885182892250477746430460414866512005225936680732094537985671236900243908114730784290372829952741399684135984046796
parts = ['0100101100001100010110110001000001001110010110110011101111100001101100000101000011111000101110011010010100101100011111000000101010011101100101010000101101110100100010101011100110001010001000000001000110000111011110011001101111110000100010000110000001110011', '1100001100001100111110011110110101001100100000000100000100011110110010010101000011111111000100001000111001100110010010010011110110110010010110110100010110100011011100101001100001010111000100000110101010101011011110110110101010110100011110010000101010000111', '1000100010110110010100111010100100111000100111100101100001011111100011000111110011101011011011100000101011000111010110010010011110100100110000001101110111001000000111100111011011000101010001111101000111100111110010011101011111100100111111011011110110101111', '1111001101111101111111111111001010001111100010100000010110011011100000000110010110000011011110101110001000001111110101101101111000000111101111111000011101011010000110111100000110000001001101101010100000010011000100010111100001011000101101111000101101110100', '1100100000100001010111110010000011000010100110101111100100011010111111110100011011111100001011101001010000100111100011100111000101110001001011110000000000000000000110111100000111100000111111010110010011000010011000110111001010000110011011111101011110000101', '0001101000011011010011100100000011010101110110111001111011000001010101101111110100011011010011111010001111011011100011111110101110101101111100100011111110011111010100001100011000111011010111110101000011110101011110110001011110001111011001101100110100000101']
for i in permutations(parts, 6):
    p = i[0] + i[1] + i[2]
    q = i[3] + i[4] + i[5]
    p = int(p, 2)
    q = int(q, 2)
    if isPrime(p) and isPrime(q):
        phi = (p-1)*(q-1)
        n = p*q
        d = pow(e, -1, phi)
        m = pow(c, d, n)
        print(long_to_bytes(m))
#flag{flbg{flcg{fldg{fleg}}}}
```

#### otp

Challenge:

```python
import random
from Crypto.Util.number import bytes_to_long

def secure_seed():
	x = 0
	# x is a random integer between 0 and 100000000000
	for i in range(10000000000):
		x += random.randint(0, random.randint(0, 10))
	return x

flag = open('flag.txt','rb').read()
flag = bytes_to_long(flag)

random.seed(secure_seed())

l = len(bin(flag)) - 1
print(l)

k = random.getrandbits(l)
flag = flag ^ k # super secure encryption
print(flag)

#328
#444466166004822947723119817789495250410386698442581656332222628158680136313528100177866881816893557
```

From the law of large numbers the secure_seed function is not secure because it should just generate one random number <br>
rather than repeatedly adding smaller numbers many many times.

Solve:

```python
from tqdm import tqdm
import random
from string import printable
from Crypto.Util.number import *

def is_printable(string):
    for c in string:
        if chr(c) not in  printable:
            return False
    return True

l = 328
enc = 444466166004822947723119817789495250410386698442581656332222628158680136313528100177866881816893557

bound = 10000000000
mid = bound*10//4
search = 1<<18
for x in tqdm(range(mid-search, mid+search)):
    random.seed(x)
    k = random.getrandbits(l)
    m = long_to_bytes(enc ^ k)
    if is_printable(m):
        print(m)
#flag{c3ntr4l_l1m1t_th30r3m_15431008597}
```

#### homophones

Who said that a plaintext letter must map to only one ciphertext letter?

SDFBE1X38 ILNVP 6RTC HXYUKLM 82ZH NVL JBE4CG 9A D5HE 7WJZH5. <br>
QZAC U2GI T6 0F! <br>
ORWH5 97 T1AXYZ6FUE L2 VT8 8XZ VKUY 15 T1UF CN JHTJI 6R9P JK4R5B.

Solve: <br>
I put all words without numbers into this auto-solver: <br>
https://www.boxentriq.com/code-breaking/cryptogram <br>

![image](https://raw.githubusercontent.com/Connor-McCartney/CTF-files/main/HSCTF-2022/Screenshots/autosolver.png)

Then I after seeing the word 'knows' I managed to guess the first three words: Everybody knows that

Then I started writing a script to replace letters: 

```python
text = """
SDFBE1X38 ILNVP 6RTC HXYUKLM 82ZH NVL JBE4CG 9A D5HE 7WJZH5.
QZAC U2GI T6 0F!
ORWH5 97 T1AXYZ6FUE L2 VT8 8XZ VKUY 15 T1UF CN JHTJI 6R9P JK4R5B.
"""

def replace(text, letters):
    for a,b in letters:
        text = text.replace(a, b)
    return text

text = replace(text, [("S", "e"), ("D", "v"), ("F", "e"), ("B", "r"), ("E", "y"), ("1", "b"), ("X", "o"), ("3", "d"), ("8", "y")]) #everybody
text = replace(text, [("I", "k"), ("L", "n"), ("N", "o"), ("V", "w"), ("P", "s")]) #knows
text = replace(text, [("6", "t"), ("R", "h"), ("T", "a"), ("C", "t")]) #that
print(text)
```

This gives us:

everybody knows that HoYUKnM y2ZH own Jry4tG 9A v5Hy 7WJZH5. <br>
QZAt U2Gk at 0e! <br>
OhWH5 97 abAoYZteUy n2 way yoZ wKUY b5 abUe to JHaJk th9s JK4h5r.

Then I keep guessing words and replacing more letters until finally: <br>

```python
text = replace(text, [("S", "e"), ("D", "v"), ("F", "e"), ("B", "r"), ("E", "y"), ("1", "b"), ("X", "o"), ("3", "d"), ("8", "y")]) #everybody
text = replace(text, [("I", "k"), ("L", "n"), ("N", "o"), ("V", "w"), ("P", "s")]) #knows
text = replace(text, [("6", "t"), ("R", "h"), ("T", "a"), ("C", "t")]) #that

text = replace(text, [("0", "m")]) #me
text = replace(text, [("Z", "u")]) #you
text = replace(text, [("2", "o")]) #no
text = replace(text, [("5", "e")]) #be
text = replace(text, [("9", "i")]) #this
text = replace(text, [("H", "r")]) #your
text = replace(text, [("A", "s")]) #is
text = replace(text, [("U", "l")]) #able
text = replace(text, [("Q", "j")]) #just
text = replace(text, [("G", "o")]) #look
text = replace(text, [("Y", "l")]) #absolutely
text = replace(text, [("K", "i"), ("M", "g")]) #rolling
text = replace(text, [("J", "c"), ("4", "p")]) #crypto
text = replace(text, [("7", "s"), ("W", "e")]) #secure
text = replace(text, [("O", "t")]) #there

print(text)
```

everybody knows that rolling your own crypto is very secure. <br>
just look at me! <br>
there is absolutely no way you will be able to crack this cipher.

Now we can pass this into the given script to get flag:

```python
import hashlib
plaintext = "everybody knows that rolling your own crypto is very secure. just look at me! there is absolutely no way you will be able to crack this cipher."
cleanedText = "".join(filter(str.isalpha,plaintext.lower()))
result = hashlib.md5(cleanedText.encode("utf-8"))
assert result.digest().hex()[:6]=="1c9ea7"
print("flag{{{}}}".format(result.digest().hex()))
#flag{1c9ea7b792ebb677aeefe01d4a862b47}
```

